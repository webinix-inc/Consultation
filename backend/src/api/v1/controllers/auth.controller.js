const User = require("../../../models/user.model");
const OTP = require("../../../models/otp.model");
const sendEmail = require("../../../jobs/email.job");
const { sendSuccess, sendError, ApiError } = require("../../../utils/response");
const { SUCCESS, ERROR } = require("../../../constants/messages");
const httpStatus = require("../../../constants/httpStatus");
const jwt = require("jsonwebtoken");
const { Consultant } = require("../../../models/consultant.model");



exports.updateProfile = async (req, res, next) => {
  try {
    const { fullName, password, currentPassword } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      throw new ApiError(ERROR.USER_NOT_FOUND, httpStatus.NOT_FOUND);
    }

    if (fullName) {
      user.fullName = fullName;
    }

    if (password) {
      if (!currentPassword) {
        throw new ApiError("Current password is required", httpStatus.BAD_REQUEST);
      }

      const isMatch = await user.comparePassword(currentPassword);
      if (!isMatch) {
        throw new ApiError("Current password is incorrect", httpStatus.UNAUTHORIZED);
      }

      user.passwordHash = password;
      user.autoGeneratedPassword = false;
    }

    await user.save();

    const responseData = {
      id: user._id,
      name: user.fullName,
      email: user.email,
      role: user.role,
    };

    return sendSuccess(res, SUCCESS.PROFILE_UPDATED, responseData);
  } catch (error) {
    next(error);
  }
};

exports.sendOtp = async (req, res, next) => {
  try {
    let { mobile } = req.body;

    // Normalize mobile number: strip all non-digit characters
    mobile = mobile.replace(/\D/g, '');

    const otp = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    await OTP.findOneAndUpdate(
      { mobile },
      { otp, expiresAt },
      { upsert: true, new: true }
    );

    console.log(`üîê OTP for ${mobile}: ${otp}`);

    return sendSuccess(res, "OTP sent successfully", { otp });
  } catch (error) {
    next(error);
  }
};

exports.verifyOtp = async (req, res, next) => {
  try {
    let { mobile, otp, role: requestedRole } = req.body;

    // Normalize mobile number: strip all non-digit characters
    mobile = mobile.replace(/\D/g, '');

    console.log(`üîç Verifying OTP - Mobile: ${mobile}, OTP: ${otp}, Requested Role: ${requestedRole || 'Any'}`);

    const otpRecord = await OTP.findOne({ mobile, otp });

    console.log(`üîç OTP Record found:`, otpRecord);

    if (!otpRecord) {
      const anyOtpForMobile = await OTP.findOne({ mobile });
      console.log(`üîç Any OTP for mobile ${mobile}:`, anyOtpForMobile);

      throw new ApiError("Invalid OTP", httpStatus.BAD_REQUEST);
    }

    if (otpRecord.expiresAt < Date.now()) {
      throw new ApiError("OTP expired", httpStatus.BAD_REQUEST);
    }

    let account = null;
    let role = null;
    let accountName = null;
    let accountEmail = null;

    // If role is specified, only check that specific model
    if (requestedRole === 'Consultant') {
      // Check Consultant model only
      const Consultant = require("../../../models/consultant.model").Consultant;
      account = await Consultant.findOne({
        $or: [
          { phone: mobile },
          { mobile: mobile }
        ]
      });

      if (account) {
        role = "Consultant";
        accountName = account.name || account.fullName || `${account.firstName} ${account.lastName}`.trim();
        accountEmail = account.email;
      }
    } else if (requestedRole === 'Client') {
      // Check Client model only
      const Client = require("../../../models/client.model");
      account = await Client.findOne({ mobile });

      if (account) {
        role = "Client";
        accountName = account.fullName;
        accountEmail = account.email;
      }
    } else if (requestedRole === 'Admin' || requestedRole === 'Employee') {
      // Check User model (Admin/Employee)
      account = await User.findOne({ mobile });

      if (account) {
        if (account.role !== requestedRole) {
          // If user exists but role mismatch, we might want to reject or just handle it
          // For now, let's just respect the found user's role
        }
        role = account.role;
        accountName = account.fullName;
        accountEmail = account.email;
      }
    } else {
      // No role specified - check all models (backward compatibility)
      // Check User model (Admin/Employee) - but skip for this portal
      // Check Consultant model
      const Consultant = require("../../../models/consultant.model").Consultant;
      account = await Consultant.findOne({
        $or: [
          { phone: mobile },
          { mobile: mobile }
        ]
      });

      if (account) {
        role = "Consultant";
        accountName = account.name || account.fullName || `${account.firstName} ${account.lastName}`.trim();
        accountEmail = account.email;
      } else {
        // Check Client model
        const Client = require("../../../models/client.model");
        account = await Client.findOne({ mobile });

        if (account) {
          role = "Client";
          accountName = account.fullName;
          accountEmail = account.email;
        }
      }
    }

    if (account) {
      // Check if account is active
      if (account.status && account.status !== 'Active') {
        if (account.status === 'Pending') {
          throw new ApiError("Your account is pending approval.", httpStatus.FORBIDDEN);
        } else if (account.status === 'Rejected') {
          throw new ApiError("Your account application has been rejected.", httpStatus.FORBIDDEN);
        } else if (account.status === 'Blocked') {
          throw new ApiError("Your account has been blocked by the administrator.", httpStatus.FORBIDDEN);
        }
        // For other non-Active statuses (Inactive, Archived, etc.)
        throw new ApiError("Account is inactive. Please contact administrator.", httpStatus.FORBIDDEN);
      }

      // Update lastLogin - use updateOne to avoid validation issues with related User references
      const modelName = account.constructor.modelName;

      if (modelName === 'Consultant') {
        const Consultant = require("../../../models/consultant.model").Consultant;
        await Consultant.updateOne({ _id: account._id }, { lastLogin: new Date() });
      } else if (modelName === 'Client') {
        const Client = require("../../../models/client.model");
        await Client.updateOne({ _id: account._id }, { lastLogin: new Date() });
      } else {
        // For User model (Admin/Employee), save normally
        account.lastLogin = new Date();
        await account.save();
      }

      const token = account.generateAuthToken();

      await OTP.deleteOne({ _id: otpRecord._id });

      return sendSuccess(res, SUCCESS.LOGIN_SUCCESS, {
        token,
        user: {
          id: account._id,
          name: accountName,
          email: accountEmail,
          role: role,
          mobile: mobile,
          avatar: account.avatar || account.image || account.profileImage || "",
          image: account.image || account.avatar || account.profileImage || "",
          profileImage: account.profileImage || account.avatar || account.image || ""
        },
        isNewUser: false
      });
    } else {
      const registrationToken = jwt.sign(
        { mobile },
        process.env.JWT_SECRET,
        { expiresIn: '15m' }
      );

      await OTP.deleteOne({ _id: otpRecord._id });

      return sendSuccess(res, "OTP verified. Please complete registration.", {
        registrationToken,
        isNewUser: true
      });
    }
  } catch (error) {
    next(error);
  }
};

exports.login = async (req, res, next) => {
  try {
    let { loginId, password } = req.body;

    if (!loginId || !password) {
      throw new ApiError("Login ID (email or mobile) and password are required", httpStatus.BAD_REQUEST);
    }

    // Normalize loginId: if it looks like a mobile number (all digits), normalize it
    // Otherwise treat it as email
    const isMobileNumber = /^[0-9+\-\s()]+$/.test(loginId);
    const normalizedLoginId = isMobileNumber ? loginId.replace(/\D/g, '') : loginId.toLowerCase();

    let account = null;
    let role = null;
    let accountName = null;
    let accountEmail = null;
    let accountMobile = null;

    // First, try to find in User model (Admin/Employee)
    account = await User.findOne({
      $or: [
        { email: normalizedLoginId },
        { mobile: isMobileNumber ? normalizedLoginId : loginId }
      ]
    });

    if (account) {
      role = account.role;
      accountName = account.fullName;
      accountEmail = account.email;
      accountMobile = account.mobile;
    } else {
      // Try Consultant model
      const Consultant = require("../../../models/consultant.model").Consultant;
      account = await Consultant.findOne({
        $or: [
          { email: normalizedLoginId },
          { phone: isMobileNumber ? normalizedLoginId : loginId },
          { mobile: isMobileNumber ? normalizedLoginId : loginId }
        ]
      });

      if (account) {
        role = "Consultant";
        accountName = account.name || account.fullName || `${account.firstName} ${account.lastName}`.trim();
        accountEmail = account.email;
        accountMobile = account.mobile || account.phone;
      } else {
        // Try Client model
        const Client = require("../../../models/client.model");
        account = await Client.findOne({
          $or: [
            { email: normalizedLoginId },
            { mobile: isMobileNumber ? normalizedLoginId : loginId }
          ]
        });

        if (account) {
          role = "Client";
          accountName = account.fullName;
          accountEmail = account.email;
          accountMobile = account.mobile;
        }
      }
    }

    if (!account) {
      throw new ApiError("Invalid login credentials", httpStatus.UNAUTHORIZED);
    }

    // Check if account has a password set
    if (!account.passwordHash) {
      throw new ApiError("Password not set. Please use OTP login or contact administrator.", httpStatus.UNAUTHORIZED);
    }

    // Verify password
    const isPasswordValid = await account.comparePassword(password);
    if (!isPasswordValid) {
      throw new ApiError("Invalid login credentials", httpStatus.UNAUTHORIZED);
    }

    // Check if account is active
    if (account.status !== 'Active') {
      if (account.status === 'Pending') {
        throw new ApiError("Your account is pending approval.", httpStatus.FORBIDDEN);
      } else if (account.status === 'Rejected') {
        throw new ApiError("Your account application has been rejected.", httpStatus.FORBIDDEN);
      } else if (account.status === 'Blocked') {
        throw new ApiError("Your account has been blocked by the administrator.", httpStatus.FORBIDDEN);
      }
      throw new ApiError("Account is inactive. Please contact administrator.", httpStatus.FORBIDDEN);
    }

    // Update last login
    account.lastLogin = new Date();
    await account.save();

    // Generate token
    const token = account.generateAuthToken();

    return sendSuccess(res, SUCCESS.LOGIN_SUCCESS, {
      token,
      user: {
        id: account._id,
        name: accountName,
        email: accountEmail,
        role: role,
        mobile: accountMobile,
        // Include profile image
        avatar: account.avatar || account.image || account.profileImage || "",
        image: account.image || account.avatar || account.profileImage || "",
        profileImage: account.profileImage || account.avatar || account.image || ""
      },
      isNewUser: false
    });
  } catch (error) {
    next(error);
  }
};

exports.register = async (req, res, next) => {
  try {
    const { registrationToken, fullName, email, role, category, subcategory } = req.body;

    let decoded;
    try {
      decoded = jwt.verify(registrationToken, process.env.JWT_SECRET);
    } catch (err) {
      throw new ApiError("Invalid or expired registration session", httpStatus.UNAUTHORIZED);
    }

    let { mobile } = decoded;

    // Normalize mobile number: strip all non-digit characters
    mobile = mobile.replace(/\D/g, '');

    if (role === 'Consultant') {
      // Check if consultant already exists
      const existingConsultant = await Consultant.findOne({
        $or: [{ email: email.toLowerCase() }, { phone: mobile }, { mobile: mobile }]
      });

      if (existingConsultant) {
        throw new ApiError("Consultant with this email or mobile already exists", httpStatus.CONFLICT);
      }

      // Get category name if category is an ObjectId
      let categoryName = 'General';
      if (category) {
        const Category = require("../../../models/category.model");
        const categoryDoc = await Category.findById(category);
        if (categoryDoc) {
          categoryName = categoryDoc.title || 'General';
        }
      }

      // Create Consultant directly
      const newConsultant = await Consultant.create({
        name: fullName,
        email: email.toLowerCase(),
        phone: mobile,
        mobile: mobile,
        category: categoryName,
        status: 'Pending'
      });

      // Trigger Notification for Admins
      try {
        const Notification = require("../../../models/notification.model");
        await Notification.create({
          name: "New Registration",
          message: `Consultant ${fullName} has registered.`,
          recipientRole: "Admin",
          type: "registration",
          avatar: "https://via.placeholder.com/40"
        });
      } catch (notifErr) {
        console.error("Failed to create registration notification:", notifErr);
      }

      const token = newConsultant.generateAuthToken();

      return sendSuccess(res, SUCCESS.USER_CREATED, {
        token,
        user: {
          id: newConsultant._id,
          name: newConsultant.name || fullName,
          email: newConsultant.email,
          role: 'Consultant',
          mobile: newConsultant.mobile || newConsultant.phone,
        }
      }, httpStatus.CREATED);

    } else if (role === 'Client') {
      // Check if client already exists
      const Client = require("../../../models/client.model");
      const existingClient = await Client.findOne({
        $or: [{ email: email.toLowerCase() }, { mobile: mobile }]
      });

      if (existingClient) {
        throw new ApiError("Client with this email or mobile already exists", httpStatus.CONFLICT);
      }

      // Create Client directly
      const newClient = await Client.create({
        fullName,
        email: email.toLowerCase(),
        mobile: mobile,
        status: 'Active'
      });

      // Trigger Notification for Admins
      try {
        const Notification = require("../../../models/notification.model");
        await Notification.create({
          name: "New Registration",
          message: `Client ${fullName} has registered.`,
          recipientRole: "Admin",
          type: "registration",
          avatar: "https://via.placeholder.com/40"
        });
      } catch (notifErr) {
        console.error("Failed to create registration notification:", notifErr);
      }

      const token = newClient.generateAuthToken();

      return sendSuccess(res, SUCCESS.USER_CREATED, {
        token,
        user: {
          id: newClient._id,
          name: newClient.fullName,
          email: newClient.email,
          role: 'Client',
          mobile: newClient.mobile,
        }
      }, httpStatus.CREATED);

    } else {
      throw new ApiError("Invalid role. Only Consultant and Client can register.", httpStatus.BAD_REQUEST);
    }

  } catch (error) {
    next(error);
  }
};

exports.signup = async (req, res, next) => {
  try {
    const { fullName, email, mobile, password, role, category, subcategory } = req.body;

    // Validate role
    if (role !== 'Client' && role !== 'Consultant') {
      throw new ApiError("Role must be either Client or Consultant", httpStatus.BAD_REQUEST);
    }

    // Normalize mobile number: strip all non-digit characters
    const normalizedMobile = mobile.replace(/\D/g, '');

    if (role === 'Consultant') {
      // Check if consultant already exists
      const Consultant = require("../../../models/consultant.model").Consultant;
      const existingConsultant = await Consultant.findOne({
        $or: [{ email: email.toLowerCase() }, { phone: normalizedMobile }, { mobile: normalizedMobile }]
      });

      if (existingConsultant) {
        throw new ApiError("Consultant with this email or mobile already exists", httpStatus.CONFLICT);
      }

      // Resolve Category Title if ID is provided
      let categoryName = category || 'General';
      const objectIdPattern = /^[0-9a-fA-F]{24}$/;
      if (category && objectIdPattern.test(category)) {
        try {
          const Category = require("../../../models/category.model");
          const categoryDoc = await Category.findById(category);
          if (categoryDoc) {
            categoryName = categoryDoc.title;
          }
        } catch (err) {
          // Ignore lookup error, treat as raw string
        }
      }

      // Create Consultant
      const newConsultant = await Consultant.create({
        name: fullName,
        email: email.toLowerCase(),
        phone: normalizedMobile,
        mobile: normalizedMobile,
        passwordHash: password, // Will be hashed by pre-save hook
        category: categoryName,
        subcategory: subcategory || '',
        status: 'Pending'
      });

      // Trigger Notification for Admins
      try {
        const Notification = require("../../../models/notification.model");
        await Notification.create({
          name: "New Registration",
          message: `Consultant ${fullName} has signed up.`,
          recipientRole: "Admin",
          type: "registration",
          avatar: "https://via.placeholder.com/40"
        });
      } catch (notifErr) {
        console.error("Failed to create registration notification:", notifErr);
      }

      const token = newConsultant.generateAuthToken();

      return sendSuccess(res, SUCCESS.USER_CREATED, {
        token,
        user: {
          id: newConsultant._id,
          name: newConsultant.name || fullName,
          email: newConsultant.email,
          role: 'Consultant',
          mobile: newConsultant.mobile || newConsultant.phone,
        }
      }, httpStatus.CREATED);

    } else {
      // Client Signup Logic (Existing)
      const Client = require("../../../models/client.model");
      const existingClient = await Client.findOne({
        $or: [{ email: email.toLowerCase() }, { mobile: normalizedMobile }]
      });

      if (existingClient) {
        throw new ApiError("Client with this email or mobile already exists", httpStatus.CONFLICT);
      }

      const newClient = await Client.create({
        fullName,
        email: email.toLowerCase(),
        mobile: normalizedMobile,
        passwordHash: password, // Will be hashed by pre-save hook
        status: 'Active'
      });

      try {
        const Notification = require("../../../models/notification.model");
        await Notification.create({
          name: "New Registration",
          message: `Client ${fullName} has signed up.`,
          recipientRole: "Admin",
          type: "registration",
          avatar: "https://via.placeholder.com/40"
        });
      } catch (notifErr) {
        console.error("Failed to create registration notification:", notifErr);
      }

      const token = newClient.generateAuthToken();

      return sendSuccess(res, SUCCESS.USER_CREATED, {
        token,
        user: {
          id: newClient._id,
          name: newClient.fullName,
          email: newClient.email,
          role: 'Client',
          mobile: newClient.mobile,
        }
      }, httpStatus.CREATED);
    }

  } catch (error) {
    next(error);
  }
};