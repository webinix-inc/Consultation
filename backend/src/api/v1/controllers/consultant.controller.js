const { Consultant } = require("../../../models/consultant.model");
const ClientConsultant = require("../../../models/clientConsultant.model");
const { sendSuccess, ApiError } = require("../../../utils/response");
const httpStatus = require("../../../constants/httpStatus");
const bcrypt = require("bcryptjs");
const { deleteFile, extractKeyFromUrl } = require("../../../services/s3.service");

exports.list = async (req, res, next) => {
  try {
    const { category, status, q } = req.query;
    const filter = {};
    if (category) filter.category = category;
    if (status) filter.status = status;
    if (q) filter.name = { $regex: q, $options: "i" };

    // Find all consultants
    let consultants = await Consultant.find(filter).sort({ createdAt: -1 });

    // Get client counts for all consultants in parallel
    const consultantsWithCounts = await Promise.all(
      consultants.map(async (consultant) => {
        // ClientConsultant.consultant references User ID, so we need to check if consultant has a user field
        // If not, we'll need to update ClientConsultant model later, but for now try both
        let clientCount = 0;
        if (consultant.user) {
          // If consultant has a user reference, use that
          clientCount = await ClientConsultant.countClientsForConsultant(consultant.user);
        } else {
          // Try using consultant ID directly (in case ClientConsultant was updated)
          clientCount = await ClientConsultant.countClientsForConsultant(consultant._id);
        }
        return {
          ...consultant.toObject(),
          clientsCount: clientCount
        };
      })
    );

    return sendSuccess(res, "Consultants fetched", consultantsWithCounts);
  } catch (error) {
    next(error);
  }
};

const { resolveConsultantDto } = require("../../../helpers/consultantHelper");

exports.getOne = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Use helper to resolve consultant by either Consultant ID or User ID
    const consultant = await resolveConsultantDto(id);

    if (!consultant) {
      throw new ApiError("Consultant not found", httpStatus.NOT_FOUND);
    }

    // Get client count (using the resolved ID, which might be a User ID or Consultant ID)
    // Note: countClientsForConsultant likely expects a User ID now since we migrated relationships
    // But let's check if we need to pass the User ID specifically
    const userId = consultant.raw?.user || consultant._id;
    const clientCount = await ClientConsultant.countClientsForConsultant(userId);

    const consultantWithCount = {
      ...consultant,
      clientsCount: clientCount
    };

    return sendSuccess(res, "Consultant fetched", consultantWithCount);
  } catch (error) {
    next(error);
  }
};

exports.create = async (req, res, next) => {
  try {
    const consultantData = { ...req.body };

    // Check if consultant already exists (by email or mobile/phone)
    const existingConsultant = await Consultant.findOne({
      $or: [
        { email: consultantData.email?.toLowerCase() },
        { phone: consultantData.phone || consultantData.mobile },
        { mobile: consultantData.mobile || consultantData.phone }
      ]
    });

    if (existingConsultant) {
      throw new ApiError("Consultant with this email or mobile already exists", httpStatus.CONFLICT);
    }

    // Ensure required fields are present
    if (!consultantData.email) {
      throw new ApiError("Email is required", httpStatus.BAD_REQUEST);
    }
    if (!consultantData.phone && !consultantData.mobile) {
      throw new ApiError("Phone or mobile number is required", httpStatus.BAD_REQUEST);
    }

    // Sync phone and mobile fields
    if (consultantData.phone && !consultantData.mobile) {
      consultantData.mobile = consultantData.phone;
    }
    if (consultantData.mobile && !consultantData.phone) {
      consultantData.phone = consultantData.mobile;
    }

    // Set name from fullName if provided
    if (consultantData.fullName && !consultantData.name) {
      consultantData.name = consultantData.fullName;
    }

    // Generate password if not provided
    let generatedPassword = null;
    if (!consultantData.passwordHash) {
      const crypto = require('crypto');
      generatedPassword = crypto.randomBytes(8).toString('hex');
      consultantData.passwordHash = generatedPassword;
      consultantData.autoGeneratedPassword = true;
    } else {
      consultantData.autoGeneratedPassword = false;
    }

    // Handle image upload from S3 (if uploaded via multer middleware)
    if (req.file) {
      consultantData.image = req.file.location;
    }

    // Set default status if not provided
    if (!consultantData.status) {
      consultantData.status = 'Pending';
    }

    // Set default category if not provided
    if (!consultantData.category) {
      consultantData.category = 'General';
    }

    const consultant = await Consultant.create(consultantData);
    
    // Return consultant data with generated password if applicable
    const consultantResponse = consultant.toObject();
    if (generatedPassword) {
      consultantResponse.generatedPassword = generatedPassword;
      consultantResponse.message = 'Consultant created successfully. Password has been generated.';
    }

    return sendSuccess(res, "Consultant created", consultantResponse, httpStatus.CREATED);
  } catch (error) {
    next(error);
  }
};

exports.update = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updateData = { ...req.body };

    // Handle image upload from S3 (if uploaded via multer middleware)
    if (req.file) {
      // Get existing consultant to delete old image
      const existingConsultant = await Consultant.findById(id);
      if (existingConsultant && existingConsultant.image) {
        try {
          // Extract S3 key from old image URL and delete it
          const oldKey = extractKeyFromUrl(existingConsultant.image);
          if (oldKey) {
            await deleteFile(oldKey);
          }
        } catch (deleteError) {
          console.error("Error deleting old image from S3:", deleteError);
          // Continue with update even if old image deletion fails
        }
      }
      // Set new image URL from S3
      updateData.image = req.file.location;
    }

    const updated = await Consultant.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true,
    });
    if (!updated) {
      throw new ApiError("Consultant not found", httpStatus.NOT_FOUND);
    }
    return sendSuccess(res, "Consultant updated", updated);
  } catch (error) {
    next(error);
  }
};

exports.remove = async (req, res, next) => {
  try {
    const { id } = req.params;
    const consultant = await Consultant.findById(id);
    
    if (!consultant) {
      throw new ApiError("Consultant not found", httpStatus.NOT_FOUND);
    }

    // Delete image from S3 if exists
    if (consultant.image) {
      try {
        const imageKey = extractKeyFromUrl(consultant.image);
        if (imageKey) {
          await deleteFile(imageKey);
        }
      } catch (deleteError) {
        console.error("Error deleting image from S3:", deleteError);
        // Continue with deletion even if S3 deletion fails
      }
    }

    const deleted = await Consultant.findByIdAndDelete(id);
    return sendSuccess(res, "Consultant deleted", { deletedId: id });
  } catch (error) {
    next(error);
  }
};

exports.approve = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updated = await Consultant.findByIdAndUpdate(
      id,
      { status: "Active" },
      { new: true }
    );
    if (!updated) {
      throw new ApiError("Consultant not found", httpStatus.NOT_FOUND);
    }
    return sendSuccess(res, "Consultant approved", updated);
  } catch (error) {
    next(error);
  }
};

exports.reject = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updated = await Consultant.findByIdAndUpdate(
      id,
      { status: "Rejected" },
      { new: true }
    );
    if (!updated) {
      throw new ApiError("Consultant not found", httpStatus.NOT_FOUND);
    }
    return sendSuccess(res, "Consultant rejected", updated);
  } catch (error) {
    next(error);
  }
};
